<div class="hide_when_mobile">
	<div class="content">
		<div class="content_socials">
			<p><a href="?page=./projects/solo.html"><img src="./assets/return.svg" class="inline_image">Back to solo projects</a></p>
		</div>
	</div>
</div>
<!--TITLE-->
<div class="content_title">
	<p>Optimizing for Playstation 1</p>
	<hr />
</div>
<!--INTRO-->
<div class="content">
	<p> 
        For the past year, I've been learning how to program games for the Playstation 1 in my spare time, using PSn00bSDK, an open source homebrew SDK for the Playstation 1, using the C programming language.
    </p>
    <p>
        This adventure started as a <a href="">silly tweet of a spinning low-poly rat with the Free Bird solo playing in the background</a>, but quickly got out of hand, and grew into an ambitious port of Sub Nivis, a game I worked on at Breda University of Applied Science.
    </p>
    <p>
        As the project progressed, I ran into problems with the game's performance, because of how many polygons the game was rendering. So, to get the performance to at least 30 fps, I had to optimize the game. In this page I will explain what I've done to keep the performance of the game up to standard.
    </p>
</div>
<hr/>
<!--QUADS-->
<div class="content">
    <h2>Quads vs Triangles</h2>
    <div class="image_grid">
        <div class="image_grid_entry">
            <img src="./assets/blog/2023/optimization_for_ps1/tri_quad_wireframe.png" />
        </div>
        <div class="image_grid_entry">
            <img src="./assets/blog/2023/optimization_for_ps1/tri_quad_concept.png" />
        </div>
    </div>
    <p>
        For some added context: technically speaking, the Playstation 1's GPU only renders triangles. However, its GPU <i>does</i> have a render command packet for rendering quads, it just splits it into 2 triangles internally. Despite that, it's still beneficial to render quads whenever possible.
    </p>
	<p> 
        Initially, the game only used triangles in the model data. This is the easiest way to implement 3D geometry, since modern graphics are all triangle-based anyway. Some formats, like glTF, don't even support other primitive types than triangles.
    </p>
    <p>
        My model format does not use index buffers, as it created too much overhead for the rendering code. This means that a quad would be represented as two triangles, so every quad would require 6 vertices. If we add support for quads in the model format, we reduce the number of vertices needed for each quad to only 4. This saves 2 vertex transformations per quad, effectively removing up to a third of our vertex processing time. If we consider the fact that most 3D-modeling workflows are quad-based, this optimization has a significant impact on the game's performance.
    </p>
</div>
<hr/>
<!--MESH SPLITTING-->
<div class="content">
    <h2>Mesh Splitting</h2>
    // todo: add fancy screenshots of the level geometry split into sections of different colors
    <p>
        Before we can continue with any of the other optimizations, we need to prepare the level geometry for it. For the next optimizations to work properly, we need to split the level into smaller clusters of polygons.
    </p>
    <p>
        To split the level geometry, I use K-means splitting. First, all the polygons in the level geometry get represented as a single position at the center of the polygon. Then, a number of random points is chosen to be the cluster centroid, based on the input size and how big we want the clusters to be. Afterwards, for each polygon, find the closest cluster centroid, and assign them to it. Then recalculate the cluster centroid based on the polygons assigned to it, and keep repeating those last two steps until we converge.
    </p>
    <p>
        After this, the level geometry is saved as one model with each cluster as a submesh.
    </p>
</div>
<!--FRUSTUM CULLING-->
<div class="content">
    <h2>Frustum Culling</h2>
    // todo: add fancy screenshots of top down view of culling in the windows build
    <p>
        When we render the level, we also process all the geometry that's off screen. This means we're spending a lot of processing power on geometry that has no impact on the frame we end up seeing on screen. Now that we have the level split into small clusters, we can easily solve this. 
    </p>
    <p>
        Frustum culling is an optimization technique where we don't render any models that are outside the camera's view frustum. To perform this test efficiently on the Playstation 1, I used some tricks. Each mesh has its own world-space axis aligned bounding box that encompasses all the mesh geometry. When drawing a mesh, we transform the 6 points of the bounding box to screen-space. Then, with those screens-space points, we create a screen-space axis aligned bounding box, and then check whether the bounding box is on screen or not. If for example, all vertices are to the left of the screen, it's off screen, so we can safely skip rendering it. 
    </p>
    <p>
        Transforming the bounding box only takes 6 vertex transformations. If the mesh is off screen, this saves rendering those 100 polygons, which is between 300 and 400 vertices we no longer have to process, saving a huge amount of rendering time.
    </p>
</div>
<!--VISIBILITY CULLING-->
<div class="content">
    <h2>Visibility Culling</h2>
    // todo: add fancy screenshots of top down view of culling in the windows build
    <p>
        With frustrm culling, we remove all the geometry that's off screen, but we still render all meshes that are on screen that would be occluded by other meshes. For example, if we're looking at a wall, and there's a level cluster that's behind the wall and not visible, we still process the mesh and draw all the triangles. What can we do about this?
    </p>
    <p>
        Here's how I solved it in my project. First, we take the collision model, and we split it into regions, by constructing a Bounding Volume Hierarchy structure for the collision triangles. We have to make sure there aren't too many layers, and that the bounding boxes of the leaf nodes aren't too small, as we don't want too many regions. The max tree depth and minimum bounding box size are hand-picked. Then, for each leaf node, we create an empty 128-bits bitfield, where each bit corresponds to one level geometry cluster. If a bit is set, it means that cluster is visible from this region, and we should render it if the player is inside it. Additionally, the bounding boxes of the regions have a bit of padding, to make sure we don't have geometry popping in and out of existence before our eyes.
    </p>
    <p>
        How do we determine which level geometry clusters are visible from a given region? The solution might be a bit cursed, but we brute force it. We take all the polygons the player can stand on in this region, and add them to a render_positions array. Then, render a cubemap of the level for every position in that array, where the color that will be stored in the cubemap corresponds to the level geometry cluster index. Then, we check all the pixels in that cubemap, and for every mesh that's visible, set the bit in the bitfield to 1.
    </p>
    <p>
        During gameplay, we figure out in which of these regions the player is standing. Then, when we render the level, we fetch the visibility list based on the region the player is in, and only render the level geometry clusters where the corresponding bit in the visibility list is set. As seen in the video below, this technique culls out a large number of level clusters, significantly reducing the number of polygons we have to process and render.
    </p>
    // todo: add video of wireframe view with geometry popping out of existence
</div>